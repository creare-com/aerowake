import datetime
import time

import numpy as np
from libs.mpu9150 import MPU9150
from libs.pwm_driver import PWM
#from sysfs.gpio import INPUT, Controller

ERROR_HARDWARE_FAULT = 999
RETRACTED = 1000

class gimbal_controller:
    def __init__(self,dt,sim=False):
        # limit switch
        #Controller.available_pins = [160] #160 on sysfs is the physical pin 40 on J3A2
        #limit_switch = Controller.alloc_pin(160, INPUT)
        #reactor.run() #this reads sysfs pins

        # USER CONFIGURABLE SETTINGS
        self.dt_des = dt # This should be 1.0/200. This drives the filtering, so make sure it is what the main loop is running at. 
        self.servo_center = 1499  # This will need to be adjusted based on the specific servo-- starting point is 1500
        self.sim = False

        ## GIMBAL STATE
        self.roll = 0
        self.roll_rate = 0
        self.pitch = 0
        self.pitch_rate = 0
        self.active = False

        ## CONTROLLER PARAMS
        self.goal = 0.0
        self.k = [5.0, 0.1, 0]
        self.ks = [0.8, 0.01, 0.02]
        self.i_thres = 200.0
        self.boost = 0.1

        ## CONTROLLER MEMORY VARIABLES
        self.e_prev = 0.0
        self.e_int = 0.0
        self.ctrl_output = 1500

        ## Initialize Hardware
        if not self.sim:
            self.imu = MPU9150(0x68,0x0C,self.dt_des,1)
            self.pwm = PWM(0x40)
        else:
            self.imu = [0,0,0,0]
            self.pwm = 900

        self.servo_ch = 3
        time.sleep(.1)


    ## Functions
    def saturate(self,val,low,high):
        if val>high:
            val=high
        if val<low:
            val=low
        return val

    # Goal set function, makes sure that the goal value is bounded
    def set_goal(self,new_goal):
        new_goal = self.saturate(new_goal,-90.0,90.0)
        self.goal=new_goal()

    # PWM function, allows Main.py to control PWM outputs if need be. 
    def set_pwm_ch(self,channel,value):
        self.pwm.setPWM(channel,0,value)

    #Move this ctrl-c catch to whatever Main.py that instantiates this controller
    def run_gimbal(self):
        try:
            #return self.run_servo_stabilize()
            return self.run_roll_stabilize()
        except KeyboardInterrupt:
            self.pwm.setPWM(self.servo_ch, 0, self.servo_center)
            quit()

    # Crude way of boosting the speed of the gimbal. 
    def ctrl_booster(self,ctrl,error):
        if (error)<-10:
            ctrl=ctrl*(1-self.boost)
        if (error)>10:
            ctrl=ctrl*(1+self.boost)
        # Saturate the ctrl input to 1000 to 2000 PWM signal. 
        return int(self.saturate(ctrl,1000,2000))

################################################################################
################################################################################

    # Specific roll controller for a standard servo mapped
    # from 1000 to 2000 = -90 to 90
    def run_servo_stabilize(self):
        if self.goal == RETRACTED:
            self.pwm.setPWM(self.servo_ch,0,1300)
            return RETRACTED
            # Read IMU and store the state
        if not self.sim:
            filtered_imu = self.imu.comp_filter()
            self.roll = filtered_imu[1]
            self.pitch = filtered_imu[0]
            self.roll_rate = filtered_imu[3]
            self.pitch_rate = filtered_imu[2]
        else:
            self.roll = 0
            self.pitch = 0
            self.roll_rate= 0
            self.pitch_rate= 0

        if(abs(self.roll) > 170.0):
            self.pwm.setPWM(self.servo_ch, 0, self.servo_center)
            self.active = False
            return ERROR_HARDWARE_FAULT

        error = self.goal - self.roll

        # Calc Derivative term OR use gyro read
        e_dot = (error - self.e_prev) / self.dt_des  #derivative calculated
        #e_dot = -self.roll_rate
        self.e_prev = error        

        # Calc Integral term
        self.e_int += error*self.dt_des
        self.e_int = self.saturate(self.e_int,-self.i_thres,self.i_thres)

        # PID control input for servo 
        self.ctrl_output = error*self.ks[0] + e_dot*self.ks[1] +self.e_int*self.ks[2]+ self.ctrl_output

        # Saturate and convert to PWM signal from 1000 to 2000, centered at 1500. 

        self.ctrl_output = (self.saturate(self.ctrl_output,1000.0,2000.0))

        # Control Boost
        #self.ctrl_output = self.ctrl_booster(self.ctrl_output,error)
        
        #print "%.2f  %.4f" %(self.ctrl_output, self.roll)
    
        # Output logic
        if self.active==True and not self.sim:
            self.pwm.setPWM(self.servo_ch, 0, self.ctrl_output)
#        if self.active==False:
#            self.pwm.setPWM(self.servo_ch, 0, self.servo_center)

        return self.roll

################################################################################
################################################################################
################################################################################


    # Call this function at DT intervals to stabilize the gimbal. 
    def run_roll_stabilize(self):
        #if gimbal target is RETRACTED, that means retract the gimbal and don't stabilize
        if(self.goal == RETRACTED):
            #if(limit_switch.read() is False):
            if(False):
                self.pwm.setPWM(self.servo_ch, 0, 1400)
            else:
                self.pwm.setPWM(self.servo_ch, 0, self.servo_center)
            return RETRACTED

        # Read IMU and store the state
        if not self.sim:
            filtered_imu = self.imu.comp_filter()
            self.roll = filtered_imu[1]
            self.pitch = filtered_imu[0]
            self.roll_rate = filtered_imu[3]
            self.pitch_rate = filtered_imu[2]
        else:
            self.roll =0
            self.pitch =0
            self.roll_rate=0
            self.pitch_rate=0

        if(abs(self.roll) > 120.0):
            self.pwm.setPWM(self.servo_ch, 0, self.servo_center)
            self.active = False
            return ERROR_HARDWARE_FAULT

        # Calculate roll error 
        error = self.goal - self.roll

        # Calc Derivative term OR use gyro read
        #e_dot = (error - self.e_prev) / self.dt_des
        e_dot = -self.roll_rate
        self.e_prev = error        

        # Calc Integral term
        self.e_int += error*self.dt_des
        self.e_int = self.saturate(self.e_int,-self.i_thres,self.i_thres)

        # PID control input for continuous rotation servo
        ctrl_input = self.k[0]*error + self.k[1]*e_dot + self.k[2]*self.e_int

        # Saturate and convert to PWM signal from 1000 to 2000, centered at 1500. 
        ctrl = int(self.saturate(ctrl_input+1500.0,1000.0,2000.0))

        # Control Boost
        ctrl_output = self.ctrl_booster(ctrl,error)

        # Output logic
        if self.active==True and not self.sim:
            self.pwm.setPWM(self.servo_ch, 0, ctrl_output)
        if self.active==False:
            self.pwm.setPWM(self.servo_ch, 0, self.servo_center)

        # Print some stuff
        #print 'Active: ',self.active,' Control Output %4.4f  Roll Angle %2.2f degrees' %(ctrl_output,self.roll)

        return self.roll
